## 分数

### ![](https://img-blog.csdn.net/20180608143817475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zfenlq/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 思路

- 选取小c，从0遍历到C，每一次遍历都计算一下当前c情况下所有人的成绩score，并看是否在前k个中，存储当前结果ans。
- 每一轮都跟上一轮的结果ans比较一下：初始情况所有人-1（出局），只要有两轮的成绩不一样就是3，一直-1就是2，一直1为1.
  1. 如果上一轮是肯定在前K，这一轮也是，ans = 1
  2. 如果上一轮是肯定在前K，这一轮出去，ans = 3
  3. 如果上一轮是不在前K，这一轮不在，ans = -1

### 误区

- 每轮比赛的权值不能出现浮点，出现浮点后可能会造成结果不精确。实际上，这道题的权值使用long就能够存下了。第i轮资格赛更新后的权值为![w_i^](http://latex.codecogs.com/svg.latex?w_i%5E)
- 排名并列就是不确定能否出线，如果第k+1名的成绩不等于第k名，那么这些并列第k名的都是稳赢。
- 胜负和的判断
  在任何情形下都胜利的人就是胜利；
  在任何情形下都失败的人就是失败；
  其余情况，就是不太确定的情况。所以遍历所有情况，每一次都看一下是否有人的成绩有变动
- 需要分两种情况考虑，有没有不确定量
  如果存在-1，那么需要枚举这个人所能够取得的一切成绩
  如果不存在-1，那么只需要考虑当前情况即可
  这道题只有一个-1，真的是已经非常友好了。
- 只看首尾是错误的
  比如C的取值为50,那么只看C=0和C=50两种情况是不够的，结果是错误的。
  因为C的取值可能影响比赛各个轮次的权重，从而影响每个人的成绩。